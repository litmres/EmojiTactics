'use strict';

const UCLOUD = '\u{2601}\u{FE0F}';
const URAIN_CLOUD = '\u{1F327}\u{FE0F}';
const UCRICKET = '\u{1F997}';
const USQUID = '\u{1F991}';
const UPEOPLE = '\u{1F465}';
const USUPERSCRIPT_DAGGER = '\u{2020}';
const USUPERSCRIPT_ONE = '\u{00B9}';
const UEXPLODE = '\u{1F4A5}';
const UOWL = '\u{1F989}';
const UPOOP = '\u{1F4A9}';
const UUNDER_BRACKET = '\u{23B5}';
const UGAS_PUMP = '\u{26FD}';
const UICE_CREAM = '\u{1F366}';
const USTOP = '\u{1F6D1}';
const UEJECT = '\u{23CF}\u{FE0F}';
const UMONEY_BAG = '\u{1F4B0}';
const UCRY = '\u{1F62D}';
const UCONFETTI = '\u{1F389}';
const UNEUTRAL_FACE = '\u{1F610}';
const URIGHT_ARROW = '\u{27A1}';
const UEYE = '\u{1F441}\u{FE0F}';
const UBRAIN = '\u{1F9E0}';
const UQUEEN = '\u{1F478}';
const UEAGLE = '\u{1F985}';
const UWOLF = '\u{1F43A}';
const USTAR = '\u{2B50}';
const USNOWMAN = '\u{26C4}';
const URAM = '\u{1F40F}';
const UAIRPLANE = '\u{2708}\u{FE0F}';
const UMAN = '\u{1F468}';
const UWOMAN = '\u{1F469}';
const UCOMPUTER = '\u{1F5A5}\u{FE0F}';
const UFACTORY = '\u{1F3ED}';
const UELF = '\u{1F9DD}';
const UDEER = '\u{1F98C}';
const USEARCH = '\u{1F50E}';
const UBEARD_MAN = '\u{1F9D4}';
const UPICK = '\u{26CF}\u{FE0F}';
const UWALKING = '\u{1F6B6}';
const UWINE_GLASS = '\u{1F377}';
const UGOAT = '\u{1F410}';
const UTORNADO = '\u{1F32A}\u{FE0F}';
const UHEART_ARROW = '\u{1F498}';
const UCHERUB = '\u{1F47C}';
const UBLOWING_KISS = '\u{1F618}';
const UKISSING = '\u{1F619}';
const UPERSON = '\u{1F464}';
const UMASKS = '\u{1F3AD}';
const UBALANCE = '\u{2696}\u{FE0F}';
const UCLOVER = '\u{1F340}';
const UHIBISCUS = '\u{1F33A}';
const UCHIPMUNK = '\u{1F43F}\u{FE0F}';
const UNUT = '\u{1F330}';
const UCIRCLE = '\u{2B55}';
const UARC = '\u{2E29}';
const ULEFT_ARC = '\u{2E28}';
const UTRIDENT = '\u{1F531}';
const UBLUE_DOT = '\u{1F535}';
const UCRYSTAL_BALL = '\u{1F52E}';
const UMOUNTAIN_BIKE = '\u{1F6B5}';
const UTENT = '\u{26FA}';
const UNATIONAL_PARK = '\u{1F3DE}\u{FE0F}';
const UVOLCANO = '\u{1F30B}';
const UFUJI = '\u{1F5FB}';
const UBAT = '\u{1F987}';
const UMILKY_WAY = '\u{1F30C}';
const USATELLITE_DISH = '\u{1F4E1}';
const USATELLITE = '\u{1F6F0}\u{FE0F}';
const UCOMET = '\u{2604}\u{FE0F}';
const UROCKET = '\u{1F680}';
const UUFO = '\u{1F6F8}';
const UALIEN = '\u{1F47D}';
const USURRENDER = '\u{1F3F3}\u{FE0F}';
const UJP_CASTLE = '\u{1F3EF}';
const UCHERRY_BLOSSOM = '\u{1F338}';
const UGREEK_TEMPLE = '\u{1F3DB}\u{FE0F}';
const UPANDA_FACE = '\u{1F43C}';
const UCROSSED_SWORDS = '\u{2694}\u{FE0F}';
const UMARTIAL_ARTS_ROBE = '\u{1F94B}';
const UEU_CASTLE = '\u{1F3F0}';
const UFLEUR_DE_LIS = '\u{269C}\u{FE0F}';
const UCROWN = '\u{1F451}';
const UROCK_HEAD = '\u{1F5FF}';
const UFACE_BLOWING = '\u{1F32C}\u{FE0F}';
const UWIZARD = '\u{1F9D9}';
const UMUSHROOM = '\u{1F344}';
const UFILE_CABINET = '\u{1F5C4}\u{FE0F}';
const URED_ANGRY = '\u{1F621}';
const UTONGUE_FACE = '\u{1F61D}';
const UANGRY = '\u{1F620}';
const UOFFICE = '\u{1F3E2}';
const UHOSPITAL = '\u{1F3E5}';
const USTORE = '\u{1F3EA}';
const UFOUNTAIN = '\u{26F2}';
const UEVERGREEN = '\u{1F332}';
const UTREE = '\u{1F333}';
const UKITCHEN_KNIFE = '\u{1F52A}';
const UPLACE_ARROW = '\u{2935}\u{fe0f}';
const UREMOVE_ARROW = '\u{2934}\u{fe0f}';
const UWEB = '\u{1F578}\u{FE0F}';
const USPIDER = '\u{1F577}\u{FE0F}';
const UNOTES = '\u{1F3B6}';
const UZZZ = '\u{1F4A4}';
const UVIOLIN = '\u{1F3BB}';
const UFRONT_CHICK = '\u{1F425}';
const UDOVE = '\u{1F54A}\u{FE0F}';
const USPARKLES = '\u{2728}';
const USPACE_INVADER = '\u{1F47E}';
const UHAMMER = '\u{1F528}';
const UHAMMER_AND_WRENCH = '\u{1F6E0}\u{FE0F}';
const UCONSTRUCTION = '\u{1F6A7}';
const USEAT = '\u{1F4BA}';
const UROBOT = '\u{1F916}';
const UNUT_BOLT = '\u{1F529}';
const UWRENCH = '\u{1F527}';
const UGEAR = '\u{2699}\u{FE0F}';
const UFLOATING_MAN = '\u{1F574}\u{FE0F}';
const URED_GOBLIN = '\u{1F47A}';
const URED_OGRE = '\u{1F479}';
const UPURPLE_IMP = '\u{1F47F}';
const UHORSE_FACE = '\u{1F434}';
const UNO = '\u{1F6AB}';
const USCROLL = '\u{1F4DC}';
const UMAN_GENIE = '\u{1F9DE}';
const UWOMAN_GENIE = '\u{1F9DE}\u{200D}';
const UAPPLE = '\u{1F34E}';
const USTRONG = '\u{1F4AA}';
const UTACO = '\u{1F32E}';
const UBURRITO = '\u{1F32F}';
const UHOT_DOG = '\u{1F32D}';
const UCHOCOLATE_BAR = '\u{1F36B}';
const UMOUTH = '\u{1F444}';
const UEYES = '\u{1F440}';
const UCRAB = '\u{1F980}';
const UBACKPACK = '\u{1F392}';
const UBENTO_BOX = '\u{1F371}';
const USUSHI = '\u{1F363}';
const UFRIED_SHRIMP = '\u{1F364}';
const URICE_BALL = '\u{1F359}';
const UDUMPLING = '\u{1F95F}';
const UGREEN_TEA = '\u{1F375}';
const UTURTLE = '\u{1F422}';
const UTREX = '\u{1F996}';
const UDINOSAUR = '\u{1F995}';
const ULIZARD = '\u{1F98E}';
const UBEE = '\u{1F41D}';
const URADIOACTIVE = '\u{2622}\u{FE0F}';
const UBOMB = '\u{1F4A3}';
const UANGER = '\u{1F4A2}';
const UDIZZY = '\u{1F4AB}';
const UBIRD = '\u{1F426}';
const UBANG = '\u{1F4A5}';
const UBIOHAZARD = '\u{2623}\u{FE0F}';
const USNAIL = '\u{1F40C}';
const UPIG = '\u{1F437}';
const USNAKE = '\u{1F40D}';
const UHANDS = '\u{1F450}';
const ULOCK = '\u{1F512}';
const UUNLOCK = '\u{1F513}';
const UFAST_FORWARD = '\u{23E9}';
const UMEDIC = '\u{26D1}';
const UHEAD_BANDAGE = '\u{1F915}';
const UEGG = '\u{1F95A}';
const UNIGHT = '\u{1F30C}';
const UWORN_HOUSE = '\u{1F3DA}';
const UCHICKEN = '\u{1F414}';
const UCOW = '\u{1F42E}';
const UCASKET = '\u{26B0}';
const UARROW = '\u{279F}';
const UTARGET = '\u{22b9}';
const UTAKEOUT = '\u{1F961}';
const UCUP_WITH_STRAW = '\u{1F964}';
const USMILE = '\u{1F642}';
const UFROWN = '\u{1F641}';
const UDUCK = '\u{1F986}';
const UCOFFEE = '\u{2615}';
const UCAT = '\u{1F408}';
const UCAT_FACE = '\u{1F431}';
const UDOG = '\u{1F415}';
const UDOG_FACE = '\u{1F436}';
const UHAMSTER = '\u{1F439}';
const UBATHTUB = '\u{1F6C1}';
const UHOUSE = '\u{1F3E0}';
const UHOUSE_AND_YARD = '\u{1F3E1}';
const UHOUSES = '\u{1F3D8}\u{FE0F}';
const URAT = '\u{1F400}';
const UDRAGON = '\u{1F409}';
const UCLOCK = '\u{23F0}';
const UPAWPRINTS = '\u{1F43E}';
const UBED = '\u{1F6CF}';
const UBUG = '\u{1F41B}';
const UDAGGER = '\u{1F5E1}';
const UMAGE = '\u{1F9D9}';
const UVAMPIRE = '\u{1F9DB}';
const UBOW = '\u{1F3F9}';
const USHIELD = '\u{1F6E1}';
const UTHINKING_FACE = '\u{1F914}';
const UHOLE = '\u{1F573}\u{FE0F}';
const USHOE = '\u{1F45F}';
const UBUTTERFLY = '\u{1F98B}';
const UFIRE = '\u{1F525}';
const UWATER = '\u{1F4A6}';
const UHEART = '\u{2764}\u{FE0F}';
const UBROKEN_HEART = '\u{1F494}';
const UDOOR = '\u{1F6AA}';
const UDEAD = '\u{2620}';
const USKULL = '\u{1F480}';
const UZOMBIE = '\u{1F9DF}';
const UOK = '\u{2705}';
const UICE = '\u{2744}\u{FE0F}';
const UELECTRIC = '\u{26A1}';
const UFOOTPRINTS = '\u{1F463}';
const UFIST = '\u{1F44A}';
const UPUFF = '\u{1F4A8}';
const UMOUNTAIN = '\u{1F3D4}\u{FE0F}';
const UBACON = '\u{1F953}';
const UANT = '\u{1F41C}';
const UFINGER_LEFT = '\u{1F448}';
const UFINGER_RIGHT = '\u{1F449}';
const UCITY = '\u{1F3D9}\u{FE0F}';
const URABBIT = '\u{1F407}';

const UJ = '\u{200D}';
const UTONE_D = '\u{1F3FF}';
const UTONE_MD = '\u{1F3FE}';
const UTONE_M = '\u{1F3FD}';
const UTONE_ML = '\u{1F3FC}';
const UTONE_L = '\u{1F3FB}';
const UFEMALE = '\u{2640}\u{FE0F}';
const UMALE = '\u{2642}\u{FE0F}';

class NotChosen {}
const TARGET_NOT_YET_CHOSEN = new NotChosen();

class RefillMarker {}
const REFILL_MARKER = new RefillMarker();

const BAL = {

    // cost:  0.14773723483085632 eval:  0.1484745740890503
    first: 0.1788,
    hp: 0.0679,
    hp2: -0.0074,
    dmg: 0.0528,
    dmg2: 0.0000,
    armor: 0.0189,
    movement: 0.0608,
    movement2: 0.0000,
    abilities: 0.0486,
    abilities2: 0.0068,
    defenseabl: 0.0179,
    defenseabl2: -0.0004,
    defensedmg: 0.0456,
    defensedmg2: -0.0004,
    leaderhp: 0.0690,
    abldefensedmg: 0.0011,


    // variables we do not yet train:
    dfreeze: 1.1,
    dzap: 1.3,
    dother: 1.1,
    ablocker: 1.5,
    aengage: 0.25,
    agrantdmg: 1.0,
    agrantarmor: 1.5,
    agranthp: 0.9,
    arangeddmg: 2.0,
    aareadmg: 4.0,
    aonetime: 0.55,
    asacrifice: 0.55,
    aspawn: 1.2,
    acopy: 1.7,
}

function uniqId() {
    return (Date.now().toString(36) + Math.random().toString(36).substr(2, 5)).toUpperCase();
}

function sum(l) {
    return l.reduce((a, b) => a + b, 0);
}

function randomChoice(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}

function hashString(str) {
    var hash = 0;
    for (var i = 0; i < str.length; i++) {
        var char = str.charCodeAt(i);
        hash = ((hash<<5)-hash)+char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
}

function deepClone(obj, hash = new WeakMap()) {
    if (Object(obj) !== obj || obj instanceof Function) return obj;
    if (hash.has(obj)) return hash.get(obj);
    try {
        var result = new obj.constructor();
    } catch(e) {
        result = Object.create(Object.getPrototypeOf(obj));
    }
    hash.set(obj, result);
    return Object.assign(result, ...Object.keys(obj).map (
        key => ({ [key]: deepClone(obj[key], hash) }) ));
}


Vue.component('emojis', {
    props: ['emoji', 'count'],
    template: `
	<transition-group name="emoji-icon" tag="div" style="display:inline-block">
        <div class="emoji-icon-item" v-bind:key="n" v-for="n in count">{{emoji}}</div>
	</transition-group>`
});

Vue.component('double-emoji', {
    props: ['back', 'front', 'size'],
    template: `
      <div style="display: inline-block" v-bind:style="{height: size+'vh', width: size+'vh'}">
        <div style="position:absolute; display: flex; align-items: center"
             v-bind:style="{height: size+'vh', width: size+'vh'}" v-if="back">
          <div style="margin: auto" v-bind:style="{fontSize: (size*0.8)+'vh'}">
            {{back}}
          </div>
        </div>
        <div style="position:absolute; display: flex; align-items: center"
             v-bind:style="{height: size+'vh', width: size+'vh'}" v-if="front">
          <div style="margin: auto" v-bind:style="{fontSize: (size*0.5)+'vh'}">
            {{front}}
          </div>
        </div>
      </div>`
});


//  Core classes


class Thing {
        * find(targetTyp, filter) {
            if (this instanceof targetTyp) {
                if ((!filter) || filter(this))  yield this;
            }
            for(var child of this.getChildren()) {
                yield* child.find(targetTyp, filter);
            }
        }
        * getChildren() {}
}

class Showable extends Thing {
    constructor() {
        super();
        this.comp = null;
    }
    getName() {
	return this.constructor.name;
    }
    getVueComponent(...parents) {
        if (this.comp == null) { this.comp = this.newVueComponent(...parents); }
        return this.comp;
    }
    newVueComponent(...parents) {
        return {data:()=>({c:this, parents}), template: this.constructor.vueTemplate};
    }
}

class Entity extends Showable {
    constructor() {
        super();
        this.id = uniqId();
        this.controller = null;
    }
    oneliner() {
	return this.getName();
    }
    getController() {
        return this.controller;
    }
    setController(controller) {
        this.controller = controller;
    }
    * getChildren() { yield* this.getAbilities(); }
    getAbilities() {
	return [];
    }
    getMeleInfo() {
        return {damage:[]};
    }
    getActionLevel(universe) {
        const actionStackIds = universe.getActionStackIds();
	return actionStackIds[this.id] || 0;
    }
}

class Trigger {
    getEmoji() {
	return null;
    }
    valueFactor() { return 1.0; }
    onDeath(tiggerHolder, dyingUnit, universe) {
    }
}

class GainHeartOnDeath extends Trigger {
    getEmoji() { return UMUSHROOM; }
    onDeath(triggerHolder, dyingUnit, universe) {
	if (dyingUnit !== triggerHolder &&
	    triggerHolder.hp > 0) {
	    triggerHolder.hp += 1;
	    triggerHolder.maxHp += 1;
	}
    }
}

class LivingEntity extends Entity {
    constructor(hp, movement, meleDamages, {
        slashArmor=0, airMovement=0,
	blocker=false, abilities=[], triggers=[],
    } = {})
    {
        super();
        this.hp = this.maxHp = hp;
        this.movement = this.maxMovement = movement;
        this.airMovement = this.maxAirMovement = airMovement;
        this.abilities = [];
        this.slashArmor = slashArmor;
	this.meleInfo = {damage: meleDamages};
	this.blocker = blocker;
	if (meleDamages.length > 0 && this.getMaxAnyMovement() > 0) {
	    this.abilities.push(new Engage());
	}
	this.abilities = this.abilities.concat(abilities);
	this.triggers = triggers;
    }
    displayableTriggers() {
	return this.triggers.filter(t => t.getEmoji() !== null);
    }
    oneliner() {
	return this.getController().id+':'+this.getName()+'['+this.hp+'h'+this.getAllMovement()+'m]';
    }
    drain() {
	this.clearAllMovement();
	for(const ability of this.abilities) {
	    ability.drain();
	}
    }
    isDrained() {
	if (this.getAllMovement() < this.getMaxAnyMovement()) return true;
	for(const ability of this.abilities) {
	    if (ability.isUsed()) return true;
	}
    }
    refill() {
        this.movement = this.maxMovement;
        this.airMovement = this.maxAirMovement;
	for(const ability of this.abilities) {
	    ability.refill();
	}
    }
    getMeleInfo() {
        return this.meleInfo;
    }
    getIconProps() {
	return {
	    front: this.getName(),
	    back: ' '
	};
    }
    getHp() { return this.hp; }
    setHp(hp) { this.hp = hp; }
    getMaxHp() { return this.maxHp; }
    setMaxHp(maxHp) { this.maxHp = maxHp; }
    getMaxMovement() { return this.maxMovement; }
    setMaxMovement(movement) { this.maxMovement = movement; }
    getMaxAirMovement() { return this.maxAirMovement; }
    setMaxAirMovement(movement) { return this.maxAirMovement = movement; }
    getAnyMovement() { return this.movement + this.airMovement; }
    getMaxAnyMovement() { return this.maxMovement + this.maxAirMovement; }
    getMovement() { return this.movement; }
    setMovement(movement) { this.movement = movement; }
    getAirMovement() { return this.airMovement; }
    setAirMovement(movement) { this.airMovement = movement; }
    getAllMovement() { return this.getMovement() + this.getAirMovement(); }
    clearAllMovement() { this.movement = this.airMovement = 0; }
    removeMovement(amount) {
	if (this.getMaxAirMovement() > 0) {
	    this.setAirMovement(Math.max(0, this.getAirMovement() - 1));
	    this.setMaxAirMovement(Math.max(0, this.getMaxAirMovement() - 1));
	} else {
	    this.setMovement(Math.max(0, this.getMovement() - 1));
	    this.setMaxMovement(Math.max(0, this.getMaxMovement() - 1));
	}
    }
    getAbilities() { return this.abilities; }
    addDamage(damage) {
	for(var dmg of this.meleInfo.damage) {
	    if (dmg.getDamageType() == damage.getDamageType()) {
		dmg.setAmount(dmg.getAmount() + damage.getAmount());
		return;
	    }
	}
	this.meleInfo.damage.push(damage);
    }
    damage(amount, damageType, source) {
        if (damageType == UDAGGER) {
            amount -= this.slashArmor;
        }
        if (amount <= 0) return;
        this.hp = Math.max(0, this.hp - amount);
    }
    getTotalDamageAmount() {
	return sum(this.getMeleInfo().damage.map(d=>d.value()));
    }
    getTotalArmor() {
	return this.slashArmor;
    }
    getMovementValueFactor() {
	return (1.0 +
		this.getMaxAnyMovement() +
		Math.sqrt(this.getMovement()) +
		2.5 * Math.sqrt(this.getAirMovement())) / 3.0;
    }
    getAbilityValueFactor() {
	let ret = sum(this.getAbilities().map(a=>a.valueFactor()));
	if (this.blocker) {
	    ret += BAL.ablocker;
	}
	ret += sum(this.triggers.map(t => t.valueFactor()));
	return ret;
    }
    value() {
	if (this.hp == 0) return 0;
	const {hp, hp2, dmg, armor, movement, abilities, abilities2, defenseabl, defenseabl2, defensedmg, defensedmg2, abldefensedmg, ..._} = BAL;

	let thp = this.getHp();
	let tdmg = this.getTotalDamageAmount();
	let tarmor = this.getTotalArmor();
	let tmov = this.getMovementValueFactor();
	let tabilities = this.getAbilityValueFactor();
	let tdefenseAbl = tabilities * (thp + tarmor + tmov);
	let tdefenseDmg = tdmg * (thp + tarmor) * (tmov ** 0.5);
	return Math.round(12.5 * ((hp * thp) +
				  (hp2 * thp * thp) +
				  (dmg * tdmg) +
				  (armor * tarmor) +
				  (movement * tmov) +
				  (abilities * tabilities) +
				  (abilities2 * tabilities * tabilities) +
				  (defenseabl * tdefenseAbl) +
				  (defenseabl2 * tdefenseAbl * tdefenseAbl) +
				  (defensedmg * tdefenseDmg) +
				  (defensedmg2 * tdefenseDmg * tdefenseDmg) +
				  (abldefensedmg * tabilities * tdefenseDmg)
				 ));
    }
    getFeatures() {
	var ret = {
	    hp: this.hp,
	    maxHp: this.maxHp,
	    blocker: (this.blocker ? 1.0 : 0.0),
	    movement: this.movement,
	    maxMovement: this.maxMovement,
	    airMovement: this.airMovement,
	    maxAirMovement: this.maxAirMovement,
	    slashArmor: this.slashArmor,
	};
	for(var dmg of this.getMeleInfo().damage) {
	    ret[dmg.constructor.name] = dmg.value();
	}
	for(var ability of this.getAbilities()) {
	    ret[ability.constructor.name] = (ability.isUsed()) ? 1 : 2;
	}
	return ret;
    }
    getBackgroundColor() {
	if (this.hp <= 0) return '#333';
	return this.getController().getColor();
    }
    newVueComponent(universe, uistate) {
        var template = `
  <div style="min-height: 2.8em; display: flex; align-items: center; justify-content: space-between; flex:1">
    <double-emoji v-bind="c.getIconProps()" size="8" style="float:left; position:relative"></double-emoji>
    <div style="margin: 0 auto 0 0; flex: 1">
      <component v-for="ability in c.getAbilities()"
	    v-bind:is="ability.getVueComponent(c, universe, uistate)"
        v-bind:key="JSON.stringify(ability)" >
      </component>
    </div>
    <div>
      <div stlye="width: 100%" style="text-align: right">
        <emojis emoji="${USTOP}" :count="c.blocker ? 1 : 0" />
        <emojis emoji="${UUNDER_BRACKET}" :count="c.maxMovement - c.movement" />
        <emojis emoji="${USHOE}" :count="c.movement" />
        <emojis emoji="${UUNDER_BRACKET}" :count="c.maxAirMovement - c.airMovement" />
        <emojis emoji="${UBUTTERFLY}" :count="c.airMovement" />
      </div>
      <div stlye="width: 100%" style="text-align: right">
        <emojis v-for="dmg in c.getMeleInfo().damage" v-bind:key="dmg.getDamageType()" :emoji="dmg.getDamageType()" :count="dmg.getAmount()" />
        <emojis v-for="trigger in c.displayableTriggers()" v-bind:key="trigger.getEmoji()" :emoji="trigger.getEmoji()" :count="1" />
        <emojis emoji="${USHIELD}" :count="c.slashArmor" />
        <emojis emoji="${UHEART}" :count="c.hp" />
        <emojis emoji="${UBROKEN_HEART}" :count="c.maxHp - c.hp" />
      </div>
    </div>
  </div>`;
        return {data:()=>({c:this, universe, uistate}), template: template};
    }

}


class Ability extends Showable {
    constructor() {
        super();
        this.id = uniqId();
    }
    isUsed() { throw new Error(); }
    setUsed(used) { throw new Error(); }
    isTargeted() { throw new Error(); }
    sound() { return SOUNDS.generic; }
    valueFactor() { return 1.0; }
    refill() { this.setUsed(false); }
    drain() { this.setUsed(true); }
    execute() {	this.setUsed(true); }
    minimumEnabled(source, universe) {
	if (source.hp <= 0 || universe.gameEnded()) return false;
	return true;
    }
    isFastEnough(universe) {
	return (universe.getTopAction() === null);
    }
    handleClick(entity, universe, uistate) {
	if (this.isTargeted()) {
            uistate.startTargeting(this, entity, universe);
	} else {
	    uistate.selectTargetlessAbility(entity, this);
	}
    }
    getStyleClass(entity, universe) {
	const in_use = universe.getActionStack().filter(a => a.ability === this).length > 0;
        if (entity.getController().isSelf()) {
	    if (in_use) return 'my-ability-in-use';
	    return 'my-ability';
	} else {
	    if (in_use) return 'opponent-ability-in-use';
            if (this.anyEnabled(entity, universe)) return 'opponent-enabled-ability';
	    return 'opponent-disabled-ability';
	}
    }
    newVueComponent(entity, universe, uistate) {
        var template = `<button
        v-bind:class="['ability-button', ability.getStyleClass(entity, universe)]"
        v-on:click="ability.handleClick(entity, universe, uistate)"
        v-if="ability.showWhenDisabled() || ability.canUse(entity, universe, uistate)"
            :disabled="!ability.canUse(entity, universe, uistate)">
            {{ability.getName()}}
        </button>
            `;
        return {data:()=>({ability:this, entity, universe, uistate}), template: template};
    }
}

class ConcreteAbility extends Ability {
    constructor() {
	super();
	this.used = false;
    }
    isUsed() { return this.used; }
    setUsed(used) { this.used = used; }
}

class WrappedAbility extends Ability {
    constructor(inner) {
	super();
	this.inner = inner;
    }
    isUsed() { return this.inner.isUsed(); }
    setUsed(used) { this.inner.setUsed(used); }
    isTargeted() { return this.inner.isTargeted(); }
    getName() { return this.inner.getName(); }
    enabled(source, universe, target) { return this.inner.enabled(source, universe, target); }
    anyEnabled(entity, universe) { return this.inner.anyEnabled(entity, universe); }
    canUse(entity, universe, uistate) { return this.inner.canUse(entity, universe, uistate); }
    *getPossibleTargets(entity, universe) { yield* this.inner.getPossibleTargets(entity, universe); }
    showWhenDisabled() { return this.inner.showWhenDisabled(); }
    execute(universe, source, target) { return this.inner.execute(universe, source, target); }
    getValueFactor() { return this.inner.getValueFactor(); }
    isFastEnough(universe) { return this.inner.isFastEnough(universe); }
    getStyleClass(entity, universe) { return this.inner.getStyleClass(entity, universe); }
    sound(source, universe, target) { return this.inner.sound(source, universe, target); }
}

class DudAbility extends WrappedAbility {
    enabled() { return false; }
    canUse(entity, universe, uistate) { return false; }
    getStyleClass(entity, universe) { return 'my-ability'; }
    newVueComponent(entity, universe, uistate) {
        var template = `<button
        class="ability-button my-ability"
	style="pointer-events: none"
        v-if="ability.showWhenDisabled() || ability.canUse(entity, universe, uistate)"
            :disabled="!ability.canUse(entity, universe, uistate)">
            {{ability.getName()}}
        </button>
            `;
        return {data:()=>({ability:this, entity, universe, uistate}), template: template};
    }
}

class TargetedAbility extends ConcreteAbility {
    targetType() { return null; }
    enabled(source, universe, target) {
	if (! this.minimumEnabled(source, universe)) return false;
	if (target == null || target instanceof Entity && target.hp <= 0) return false;
	return true;
    }
    targetType() { return Entity; }
    availableWhenSourceIsInAction() { return false; }
    isTargeted() { return true; }
    * getPossibleTargets(entity, universe) {
	const actionStackIds = universe.getActionStackIds()
        var targetTyp = this.targetType();
	// Most entities already queued in the action stack cannot act:
        if ((!this.availableWhenSourceIsInAction()) && actionStackIds[entity.id]) return;
	// ability must be faster than currently queued actions
	if (!this.isFastEnough(universe)) return;
        if (Action === targetTyp) {
            for(var action of universe.getActionStack()) {
                if (this.enabled(entity, universe, action)) yield action;
            }
        } else {
	    var checker;
	    if (universe.isResponding()) {
		const stackSize = universe.getActionStack().length;
		checker = (t) => (actionStackIds[t.id] && this.enabled(entity, universe, t));
	    } else {
		checker = (t) => this.enabled(entity, universe, t);
	    }
            for(var otherEntity of universe.getEntities()) {
                if (otherEntity instanceof targetTyp) {
                    if (checker(otherEntity)) yield otherEntity;
                }
            }
        }
    }
    anyEnabled(entity, universe) {
        for(var target of this.getPossibleTargets(entity, universe)) {
            return true;
        }
        return false;
    }
    canUse(entity, universe, uistate) {
        return (entity.getController().isSelf() &&
                this.anyEnabled(entity, universe) &&
                uistate.isActing() &&
                uistate.targeting == null);
    }
    showWhenDisabled() { return true; }
}

class Placeholder extends TargetedAbility {
    constructor(icon) {
	super();
	this.icon = icon;
    }
    targetType() { return Entity; }
    valueFactor() { return 0; }
    getName() { return this.icon; }
    enabled(source, universe) {
	return !this.isUsed();
    }
    execute(universe, evader, target) {
	this.setUsed(true);
    }
}

class TargetlessAbility extends ConcreteAbility {
    targetType() { return null; }
    constructor() {
	super();
    }
    enabled(source, universe) {
        return (!this.isUsed() &&
		this.minimumEnabled(source, universe));
    }
    anyEnabled(source, universe) {
	if (!this.isFastEnough(universe)) return false;
        return this.enabled(source, universe) && ! universe.isResponding();
    }
    isTargeted() { return false; }
    canUse(entity, universe, uistate) {
        return (entity.getController().isSelf() &&
                this.anyEnabled(entity, universe) &&
                uistate.isActing() &&
                uistate.targeting == null);
    }
    showWhenDisabled() { return true; }
}

class Engage extends TargetedAbility {
    valueFactor() { return BAL.aengage; }
    getName() { return UTARGET; }
    sound(source) {
	if (source.meleInfo.damage.length > 0) {
	    return source.meleInfo.damage[0].sound();
	} else {
	    return null;
	}
    }
    enabled(source, universe, target) {
	if (source.getController() != target.getController() &&
	    source.getAllMovement() > 0 &&
	    super.enabled(source, universe, target))
	{
	    if (target.blocker) return true;
	    if (source.getAllMovement() >= target.getAllMovement() &&
		source.getAirMovement() >= target.getAirMovement()) {
		// expensive check for blockers
		if (source.getAirMovement() <= 0.0 &&
		    universe.hasBlocker(target.getController().id)) return false;
		return true;
	    }
	}
	return false;
    }
    execute(universe, source, target) {
	if (target !== null) {
	    // battle logic is now symmetric between source and target
            universe.dealDamage(source, target, source.getMeleInfo().damage);
	    universe.dealDamage(target, source, target.getMeleInfo().damage);
	    source.clearAllMovement();
	    target.clearAllMovement();
	}
    }
}

class FriendlyTargetedAbility extends TargetedAbility {
    enabled(source, universe, target) {
	if (source.getController() !== target.getController()) return false;
	if (source === target) return false;
	if (this.isUsed()) return false;
	return super.enabled(source, universe, target);
    }
}

class OpponentTargetedAbility extends TargetedAbility {
    enabled(source, universe, target) {
	if (source.getController() === target.getController()) return false;
	if (this.isUsed()) return false;
	return super.enabled(source, universe, target);
    }
}

class RefillTarget extends FriendlyTargetedAbility {
    getName() { return UFINGER_RIGHT; }
    execute(universe, source, target) {
	this.setUsed(true);
	if (! target.isDrained()) return false;
	target.refill();
    }
}

class RefillSelf extends TargetlessAbility {
    getName() { return UEYES; }
    enabled(source, universe) {
	return super.enabled(source, universe) && source.isDrained();
    }
    execute(universe, source, target) {
	source.refill();
	this.setUsed(true);
    }
}

class GlobalRemoveMovement extends TargetlessAbility {
    getName() { return ULEFT_ARC + USHOE + UREMOVE_ARROW + UARC; }
    execute(universe, source, target) {
	this.setUsed(true);
	for(const target of universe.getEntities()) {
	    target.removeMovement(1);
	}
    }
}

class GrantDamage extends FriendlyTargetedAbility {
    constructor(dmg) {
	super();
	this.dmg = dmg;
    }
    getName() { return this.dmg.getDamageType() + UPLACE_ARROW; }
    valueFactor() { return this.dmg.value() * BAL.agrantdmg; }
    execute(universe, source, target) {
	source.setHp(0);
	target.addDamage(this.dmg);
    }
}

class GrantAirMovement extends FriendlyTargetedAbility {
    constructor(amount) {
	super();
	this.amount = amount;
    }
    getName() { return UBUTTERFLY.repeat(this.amount) + UPLACE_ARROW; }
    execute(universe, source, target) {
	target.setAirMovement(target.getAirMovement() + this.amount);
	target.setMaxAirMovement(target.getMaxAirMovement() + this.amount);
    }
}

class GrantMovement extends FriendlyTargetedAbility {
    constructor(amount) {
	super();
	this.amount = amount;
    }
    getName() { return USHOE.repeat(this.amount) + UPLACE_ARROW; }
    execute(universe, source, target) {
	source.setHp(0);
	target.setMovement(target.getMovement() + this.amount);
	target.setMaxMovement(target.getMaxMovement() + this.amount);
    }
}

// NOTE: must be the outermost ability because it depends on identity checks
class OneTime extends WrappedAbility {
    valueFactor() { return this.inner.valueFactor() * BAL.aonetime; }
    getName() { return this.inner.getName() + USUPERSCRIPT_ONE; }
    execute(universe, source, target) {
	this.inner.execute(universe, source, target);
	const filtered = source.abilities.filter(e => e !== this);
	if (filtered.length != source.abilities.length - 1) throw new Error();
	source.abilities = filtered;
    }
}

class SacrificeTo extends WrappedAbility {
    valueFactor() { return this.inner.valueFactor() * BAL.asacrifice; }
    getName() { return this.inner.getName() + USUPERSCRIPT_DAGGER; }
    execute(universe, source, target) {
	this.inner.execute(universe, source, target);
	source.setHp(0);
    }
}

class GrantArmor extends FriendlyTargetedAbility {
    constructor(symbol = USHIELD + UPLACE_ARROW) {
	super();
	this.symbol = symbol;
    }
    getName() { return this.symbol; }
    valueFactor() { return BAL.agrantarmor; }
    execute(universe, source, target) {
	target.slashArmor += 1;
    }
}

class HealTarget extends FriendlyTargetedAbility {
    constructor(amount, symbol = UHEAD_BANDAGE) {
	super();
	this.amount = amount;
	this.symbol = symbol;
    }
    getName() { return this.symbol; }
    targetType() { return Entity; }
    enabled(source, universe, target) {
	if (source.getController() !== target.getController()) return false;
	if (target.getHp() >= target.getMaxHp()) return false;
	if (this.isUsed()) return false;
	return super.enabled(source, universe, target);
    }
    execute(universe, source, target) {
	this.setUsed(true);
	source.clearAllMovement();
	universe.heal(source, target, this.amount);
    }
}

class Universe extends Thing {
    constructor(players, entities) {
	super();
        this.players = players;
        this.entities = entities;
	this.actionStack = [];
        this.curPlayerIndex = 0;
	this.passCount = 0;
	this.roundNumber = 1;
    }
    oneliner() {
	return '[' + this.getCurPlayer().id + '] ' +this.entities.map((u)=>u.oneliner()).join(',')+' '+this.actionStack.map((a)=>a.oneliner());
    }
    getFeatures() {
	const curId = this.getCurPlayer().id;
	var ret = {};
	const playerSelectors =[(e => e.getController().id == curId),
				(e => e.getController().id != curId)];
	for(const [lbl, selectLeader] of [['leaders',(e => e instanceof Leader)],
					  ['extras',(e => ! e instanceof Leader)]]) {
	    const entities = this.entities.filter(selectLeader);
	    ret[lbl] = playerSelectors.map(sel => entities.filter(sel)).map(e => e.getFeatures());
	    ret[lbl].sort((a,b) => b.hp - a.hp);
	}
	return ret;
    }
    scoreEntityFeatures(co, features) {
	return 0;
    }
    getPlayers() {
	return this.players;
    }
    * getChildren() {
        for(var entity of this.entities) {
	    yield entity;
	}
	for(const action of this.action_stack) {
	    yield action;
	}
    }
    addEntity(entity, controller) {
        entity.setController(controller);
        this.entities.push(entity);
    }
    getCurPlayer() {
	const topAction = this.getTopAction();
        if (topAction == null) {
            return this.players[this.curPlayerIndex];
        } else {
            var topActionOwner = topAction.source.getController();
            return (topActionOwner.id == this.players[1].id) ? this.players[0] : this.players[1];
        }
    }
    getDisplayPlayer() {
	const topAction = this.getTopAction();
	if (topAction == null) {
	    return this.players[this.curPlayerIndex];
	} else {
	    var topActionOwner = topAction.source.getController();
	    var actorIsPlayer0 = topActionOwner.id == this.players[0].id;
	    return (actorIsPlayer0 ? this.players[0] : this.players[1]);
	}
    }
    isResponding() {
        return this.actionStack.length > 0;
    }
    refill() {
        for(var entity of this.getEntities()) {
            entity.refill();
        }
	for(var player of this.players) {
	    player.refill(this);
	}
    }
    getLeader(playerId) {
	var leaders = this.entities.filter(e => (e instanceof Leader && e.getController().id == playerId));
	if (leaders.length == 1) return leaders[0];
	return null;
    }
    gameEnded() {
	var entityCounts = {}
	var leaders = this.entities.filter(e => (e instanceof Leader && e.hp > 0));
        for(var entity of leaders) {
	    entityCounts[entity.getController().id] += 1;
	}
	const numleft = Object.keys(entityCounts).length
	if (numleft > 1) return false;
	if (numleft == 0) return 'tie';
	return leaders[0].getController();
    }
    autoPass() {
	this.resolvePass();
	if (this.isResponding()) {
	    this.actionStack.pop();
	}
	this.applyDeath();
	this.next();
    }
    next() {
        if (!this.isResponding()) {
            this.curPlayerIndex = (this.curPlayerIndex + 1) % this.players.length;
        }
    }
    pushAction(action) {
	this.actionStack.push(action);
	this.passCount = 0;
    }
    resolvePass() {
	var action = null;
        if (this.isResponding()) {
            action = this.executeTopAction();
	    this.passCount = 0;
        } else {
	    this.passCount += 1;
	    if (this.passCount >= 2) {
		this.roundNumber += 1;
		this.refill();
		this.passCount = 0;
		return REFILL_MARKER;
	    }
        }
	return action;
    }
    heal(source, target, amount) {
        target.hp = Math.min(target.hp + amount, target.maxHp);
    }
    dealDamage(source, target, damages) {
	for(const dmg of damages) {
	    dmg.execute(this, source, target);
	}
    }
    applyDeath() {
	var keepChecking = true;
	while(keepChecking) {
	    keepChecking = false;
	    for(var entity of this.find(Entity)) {
		if (entity.hp > 0) continue;
		for(var reactor of this.find(Entity)) {
		    for(var trigger of reactor.triggers) {
			trigger.onDeath(reactor, entity, this);
		    }
		}
		this.entities = this.entities.filter(e => (e !== entity));
		keepChecking = true;
		break;
	    }
	}
    }
    * getChildren() {
        for(var entity of this.entities) {
            yield entity;
        }
        for(var action of this.actionStack) {
            yield action;
        }
    }
    getEntities() {
        return this.entities;
    }
    getTopAction() {
	var i = this.actionStack.length - 1;
	while (i >= 0) {
	    const top = this.actionStack[i];
	    if (top.target !== TARGET_NOT_YET_CHOSEN) return top;
	    i -= 1;
	}
	return null;
    }
    executeTopAction() {
	var action = this.getTopAction();
        if (action.ability.enabled(action.source, this, action.target)) {
            action.ability.execute(this, action.source, action.target);
        }
	return action;
    }
    getActionStack() {
        return this.actionStack;
    }
    getActionStackIds() {
        var stackIds = {};
        var actionIndex = 1;
        for(var action of this.actionStack) {
            stackIds[action.source.id] = actionIndex;
            if (action.target !== null) {
                stackIds[action.target.id] = actionIndex;
            }
            actionIndex += 1;
        }
        for(var entity of this.entities) {
            var found = Array.from(entity.find(Thing, e => stackIds[e.id]));
            if (found.length == 0) continue;
            actionIndex = stackIds[found[0].id];
            for(var thing of entity.find(Thing)) {
                stackIds[thing.id] = actionIndex;
            }
        }
        return stackIds;
    }
    hasBlocker(playerId) {
	for(var entity of this.find(LivingEntity, (e) => e.getController().id == playerId)) {
	    if (entity.blocker) return true;
	}
	return false;
    }
    valueForPlayer(playerId) {
	var score = 0.0;
	var fragility = 0.0;
	for(var entity of this.find(LivingEntity)) {
	    if (entity.getController().id != playerId) continue;
	    score += entity.value();
	    if (entity instanceof Leader) {
		fragility = 1.0 - (entity.hp / entity.maxHp);
	    }
	}
	return score * (1.0 - Math.pow(fragility, 1.3));
    }
    getHash() {
	return JSON.stringify([
	    this.getCurPlayer().id,
	    Array.from(this.find(Entity)).map(e => [e.getName(), e.getFeatures(), e.getController().id]).sort(),
	    this.actionStack.map(a => a.getHash())
	]);
    }
}

class UiState {
    constructor(universe, soundPlayer) {
        this.targeting = null;
        this.universe = universe;
	this.soundPlayer = soundPlayer;
    }
    isActing() {
        return this.universe.getCurPlayer().isSelf();
    }
    isLeading() {
        return this.universe.getActionStack().length == 0 && this.targeting == null;
    }
    getSortedEntities() {
        var copy = this.universe.getEntities().slice();
        copy.sort((a,b) => {
            var criteria = a.getController().isSelf() - b.getController().isSelf();
            if (criteria != 0) return criteria;
	    criteria = b.getActionLevel(this.universe) - a.getActionLevel(this.universe);
            if (!a.getController().isSelf()) criteria = -1 * criteria;
            if (criteria != 0) return criteria;
            criteria = a.getAllMovement() - b.getAllMovement();
            if (!a.getController().isSelf()) criteria = -1 * criteria;
            if (criteria != 0) return criteria;
            return a.id - b.id;
        });
        return copy;
    }
    triggerOpponent() {
	this.universe.next();
	
	// Fast track if opponent can only pass:
	if (!this.universe.getCurPlayer().isSelf()) {
	    if (Array.from(this.universe.getCurPlayer().getOptions(this.universe)).length == 0) {
		this.pass();
		return;
	    }
	}
	setTimeout(() => {
	    this.universe.applyDeath();
	    if (!this.universe.getCurPlayer().isSelf()) {
		if (this.universe.gameEnded()) {
		    this.pass();
		} else {
		    this.universe.getCurPlayer().act(this.universe, this);
		}
	    }
	}, 600);
    }
    pass() {
	var action = this.universe.resolvePass();
	if (action == null) {
	    this.soundPlayer(SOUNDS.turn);
	} else if (action === REFILL_MARKER) {
	    this.soundPlayer(SOUNDS.upsound);
	} else if (action) {
	    var sound = action.ability.sound(action.source, action.universe, action.target);
	    if (sound) {
		this.soundPlayer(sound);
	    }
	}
        if (this.universe.isResponding()) {
	    // additional delay to move units back into position
	    setTimeout(() => {
		this.universe.actionStack.pop();
		this.triggerOpponent();
	    }, 600);
	} else {
	    this.triggerOpponent();
	}
    }
    selectTargetlessAbility(entity, ability) {
        this.universe.pushAction(new Action(entity, ability, null));
	this.triggerOpponent();
    }
    startTargeting(ability, entity, universe) {
        var targets = new Set(Array.from(ability.getPossibleTargets(entity, universe)).map(t => t.id));
        this.targeting = {source:entity, ability:ability, targets: targets}
        var action = new Action(entity, ability, TARGET_NOT_YET_CHOSEN);
	universe.actionStack.push(action);
    }
    selectTarget(target) {
	this.universe.actionStack[this.universe.actionStack.length - 1].target = target;
	this.universe.passCount = 0;
        this.targeting = null;
	
	this.triggerOpponent();
    }
    cancelTargeting() {
	this.targeting = null;
	this.universe.actionStack.pop();
    }
}

class Player {
    constructor(id) {
	this.id = id;
	this.roster = [];
	this.library = {Hero4: 1};
    }
    refill(universe) {
	this.spawn(universe);
    }
    setRoster(roster) {
	this.roster = roster;
    }
    spawn(universe) {
	while(true) {
	    if (this.roster.length == 0) return;
	    var next = this.roster[0];
	    const cost = (new next()).value();
	    this.roster = this.roster.slice(1);
            const entity = new next();
            entity.setController(this);
            universe.getEntities().push(entity);
	}
    }
    * getOptions(universe) {
        for(var entity of universe.getEntities()) {
            if (entity.getController() != this) continue;
            for(var ability of entity.getAbilities()) {
                if (ability.isTargeted()) {
                    for(var target of ability.getPossibleTargets(entity, universe)) {
                        yield new Action(entity, ability, target);
                    }
                } else {
                    if (ability.anyEnabled(entity, universe)) {
                        yield new Action(entity, ability, null);
                    }
                }
            }
        }
    }
}

class UiPlayer extends Player {
    constructor() {
	super('pl');
    }
    getColor() { return '#034'; }
    isSelf() { return true; }
}

class Action extends Showable {
    constructor(source, ability, target) {
	super();
        this.source = source;
        this.ability = ability;
        this.target = target;
    }
    enabled(universe) {
	return this.ability.enabled(this.source, universe, this.target)
    }
    oneliner() {
	var line = this.source.getController().id + ':' + this.source.getName() + ' ' + this.ability.getName();
	if (this.target instanceof Entity) {
	    line += ' ' + UARROW + ' ' + this.target.getName();
	}
	return line;
    }
    getTargetIconProps() {
	if (this.target instanceof Entity) {
	    return this.target.getIconProps();
	}
	if (this.target instanceof Action) {
	    this.target.source.getIconProps();
	}
    }
    newVueComponent(universe, uistate) {
	var line = this.source.getName() + ' ' + this.ability.getName();
        var template = `<div style="display:flex; align-items: center">
	    <double-emoji v-bind="action.source.getIconProps()" size="5" style="display:inline-block"></double-emoji>
	    <div style="display:inline-block; margin:auto">
	      {{action.ability.getName()}}
	    </div>
	    <div style="display:inline-block; margin:auto" v-if="action.getTargetIconProps()">
              ${UARROW}
	    </div>
	    <double-emoji v-if="action.getTargetIconProps()" v-bind="action.getTargetIconProps()" size="5" style="display:inline-block"></double-emoji>
	</div>`;
        return {data:()=>({action:this, universe, uistate}), template: template};
    }
    getHash() {
	return (this.source.id + this.ability.getName() +
		((this.target === null) ? 0 : this.target.id));
    }
}
 

class Damage {
    sound() { return null; }
    rangedSound() { return this.sound(); }
    value() { return this.getAmount(); }
    getAmount() { return this.amount; }
    setAmount(amount) { this.amount = amount; }
    getName() { return this.getDamageType().repeat(this.amount); }
    execute(universe, source, target) {
        target.damage(this.getAmount(), this.getDamageType(), source);
    }
}

class Punch extends Damage {
    constructor(amount) { super(); this.amount = amount; }
    sound() { return SOUNDS.punch; }
    value() { return this.getAmount() * BAL.dother; }
    getDamageType() { return UFIST; }
}

class Bite extends Damage {
    constructor(amount) { super(); this.amount = amount; }
    getDamageType() { return UDAGGER; }
    sound() { return SOUNDS.chomp; }
}

class Slash extends Damage {
    constructor(amount) { super(); this.amount = amount; }
    sound() { return SOUNDS.slash; }
    rangedSound() { return SOUNDS.swoosh; }
    getDamageType() { return UDAGGER; }
}

class Poison extends Damage {
    constructor(amount) { super(); this.amount = amount; }
    value() { return this.getAmount() * BAL.dother; }
    getDamageType() { return UBIOHAZARD; }
}

class Burn extends Damage {
    constructor(amount) { super(); this.amount = amount; }
    value() { return this.getAmount() * BAL.dother; }
    sound() { return SOUNDS.burn; }
    getDamageType() { return UFIRE; }
}

class Freeze extends Damage {
    constructor() {
	super(0);
	this.amount = 1;
    }
    getName() { return UICE; }
    value() { return BAL.dfreeze; }
    getDamageType() { return UICE; }
    execute(universe, source, target) {
	target.drain();
    }
    sound() { return SOUNDS.freeze; }
}

class Lance extends Damage {
    getDamageType() { return UDAGGER + UPUFF; }
    getAmount() { return 1; } // just for the icon
    value() { return super.value() * 3.0; }
    sound() { return SOUNDS.slash; }
    execute(universe, source, target) {
	var amount = 1 + Math.max(0, source.getAllMovement() - target.getAllMovement());
        target.damage(amount, UDAGGER, source);
    }
}

class Zap extends Damage {
    constructor(amount) { super(); this.amount = amount; }
    getDamageType() { return UELECTRIC; }
    value() { return super.value() * BAL.dzap; }
    sound() { return SOUNDS.zap; }
    execute(universe, source, target) {
	super.execute(universe, source, target);
	for(const ability of target.abilities) {
	    if (!(ability instanceof Engage)) {
		ability.setUsed(true);
	    }
	}
    }
}

class ShootWeb extends OpponentTargetedAbility {
    getName() { return UWEB; }
    enabled(source, universe, target) {
	return ((!this.isUsed()) &&
		target.getAllMovement() > 0 &&
		super.enabled(source, universe, target));
    }
    execute(universe, source, target) {
	this.setUsed(true);
	source.clearAllMovement();
	target.clearAllMovement();
    }
}

class AreaWeb extends TargetlessAbility {
    getName() { return UWEB + UARC; }
    valueFactor() { return BAL.aareadmg * 1.0; }
    execute(universe, source) {
	this.setUsed(true);
	const myController = source.getController().id;
	for(const target of universe.getEntities()) {
	    if (target.getController().id != myController) {
		target.clearAllMovement();
	    }
	}
    }
}

class GlobalWeb extends TargetlessAbility {
    getName() { return ULEFT_ARC + UWEB + UARC; }
    valueFactor() { return BAL.aareadmg * 0.25; }
    execute(universe, source) {
	this.setUsed(true);
	for(const target of universe.getEntities()) {
	    target.clearAllMovement();
	}
    }
}

class GlobalSleep extends TargetlessAbility {
    getName() { return ULEFT_ARC + UICE + UARC; }
    valueFactor() { return 0.25 * BAL.aareadmg * (new Freeze()).value(); }
    execute(universe, source) {
	this.setUsed(true);
	for(const target of universe.getEntities()) {
	    target.drain();
	}
    }
}

class Quake extends TargetlessAbility {
    getName() { return UDIZZY; }
    execute(universe, source) {
	this.setUsed(true);
	for(const target of universe.getEntities()) {
	    target.setMovement(0);
	}
    }
}

class Charm extends OpponentTargetedAbility {
    constructor(icon) {
	super();
	this.icon = icon;
    }
    getName() { return this.icon; }
    valueFactor() { return BAL.acopy * 4.5; }
    enabled(source, universe, target) {
	return (super.enabled(source, universe, target) &&
		(!(target instanceof Leader)));
    }
    execute(universe, source, target) {
	target.setController(source.getController());
	source.abilities = source.abilities.filter(e => e !== this);
    }
}

class RangedDamageAbility extends OpponentTargetedAbility {
    constructor(damages) {
	super();
	this.damages = damages;
    }
    sound() {
	return this.damages[0].rangedSound();
    }
    getName() {
	return this.damages.map(d => d.getName()).join('')+UBOW;
    }
    valueFactor() { return BAL.arangeddmg * sum(this.damages.map(d=>d.value())); }
    execute(universe, source, target) {
	if (target !== null) {
	    this.setUsed(true);
            universe.dealDamage(source, target, this.damages);
	}
    }
}

class PiercingProjectile extends RangedDamageAbility {
    constructor(amount) {
	super([new Slash(amount)]);
    }
}

class Nut extends RangedDamageAbility {
    constructor() {
	super([new Punch(1)]);
    }
    getName() { return super.getName() + USUPERSCRIPT_ONE; }
    execute(universe, source, target) {
	super.execute(universe, source, target);
	source.abilities = source.abilities.filter(e => e !== this);
    }
}

class FreezeProjectile extends RangedDamageAbility {
    constructor() {
	super([new Freeze()]);
    }
}

class FireProjectile extends RangedDamageAbility {
    constructor(amount) {
	super([new Burn(amount)]);
    }
}

class ZapProjectile extends RangedDamageAbility {
    constructor(amount) {
	super([new Zap(amount)]);
    }
}

class Tornado extends RangedDamageAbility {
    constructor(amount) {
	super([new Punch(amount)]);
	this.amount = amount;
    }
    valueFactor() { return super.valueFactor() * 0.5; }
    getName() { return UTORNADO.repeat(this.amount) + UBOW; }
    enabled(source, universe, target) {
	return (super.enabled(source, universe, target) &&
		(target.getMaxAirMovement() > 0 || target.getMovement() > 0));
    }
    execute(universe, source, target) {
	target.setMovement(0);
	target.setAirMovement(0);
	if (target.getMaxAirMovement() > 0) {
	    super.execute(universe, source, target);
	}
    }
}

class AreaDamage extends TargetlessAbility {
    constructor(dmg) {
	super();
	this.dmg = dmg;
    }
    sound() { return this.dmg.rangedSound(); }
    getName() {
	return this.dmg.getName() + UARC;
    }
    valueFactor() {
	return this.dmg.value() * BAL.aareadmg;
    }
    enabled(source, universe) {
	if (! super.enabled(source, universe)) return false;
	for(var entity of universe.getEntities()) {
	    if (this.affects(source, entity)) return true;
	}
	return false;
    }
    affects(source, target) {
	return source.getController().id != target.getController().id;
    }
    execute(universe, source) {
	for(var entity of universe.getEntities()) {
	    if (this.affects(source, entity)) {
		universe.dealDamage(source, entity, [this.dmg]);
	    }
	}
	this.setUsed(true);
    }
}

class GlobalDamage extends AreaDamage {
    getName() {
	return ULEFT_ARC + this.dmg.getName() + UARC;
    }
    affects(source, target) {
	return true;
    }
    valueFactor() {
	return super.valueFactor() * 0.75;
    }
}

class Spawn extends TargetlessAbility {
    constructor(typ, icon) {
	super();
	this.typ = typ;
	this.icon = icon;
    }
    valueFactor() {
	var example = new (this.typ)();
	example.abilities = example.abilities.filter(a => !(a instanceof Spawn));
	return BAL.aspawn * (example.value() / (new Duck()).value());
    }
    getName() { return this.icon + '*'; }
    execute(universe, source) {
	source.clearAllMovement();
        var newEntity = new (this.typ)();
        newEntity.setController(source.getController());
	newEntity.drain();
        universe.getEntities().push(newEntity);
	this.setUsed(true);
    }
}

class Kiss extends FriendlyTargetedAbility {
    getName() { return UHEART + UPLACE_ARROW; }
    valueFactor() { return BAL.agranthp; }
    execute(universe, source, target) {
	target.maxHp += 1;
	target.hp += 1;
	this.setUsed(true);
    }
}

class AreaGrantHp extends TargetlessAbility {
    getName() { return ULEFT_ARC + UHEART + UPLACE_ARROW; }
    valueFactor() { return BAL.aareadmg * BAL.agranthp; }
    execute(universe, source) {
	this.setUsed(true);
	const myController = source.getController().id;
	for(const target of universe.getEntities()) {
	    if (target.getController().id == myController) {
		target.maxHp += 1;
		target.hp += 1;
	    }
	}
    }
}

class Masquerade extends TargetedAbility {
    getName() { return UMASKS; }
    enabled(source, universe, target) {
	return (super.enabled(source, universe, target) &&
		(! this.isUsed()) &&
		(!(target instanceof Leader)) &&
		(target != source));
    }
    valueFactor() { return BAL.acopy; }
    execute(universe, source, target) {
        var copy = new target.constructor();
	copy.id = source.id;
	copy.setController(source.getController());
	copy.setHp(1);
	copy.setMaxHp(1);
        universe.entities = universe.entities.map( e => (e === source) ? copy : e);
	this.setUsed(true);
    }
}
